<p id="results"></p>


<script src="repeatTests_v1.js"></script>
<script>

const dataframe = [
    [25,20,60,25,15,50,15,50,35,25],//y for t1
    [75,45,80,65,55,30,15,35,50,35],//y for t2
    [85,50,85,85,45,40,45,40,70,65],//y for t3
]

const newdata = [
    [12,39,36,17,25,15,8,31,45,37,13,50,35,40,33,17,20,42,31,24,15,13,9,21,31,13,12,10,19,18,14,8,7,19,25,26],
    [17.5,104.6,64.7,47,22,12.4,20,79.7,70.8,45.9,47.5,77.8,70.9,84.8,49.8,34.6,71.4,55,54,27.9,40.6,33,22.2,80.5,80,41,35,33,34.2,43.2,20,37,28.2,46.4,64.9,59.4],
    [1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ],
    [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    ],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0    ],
    [17.5,104.6,64.7,47,22,12.4,20,79.7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    ],
    [0,0,0,0,0,0,0,0,70.8,45.9,47.5,77.8,70.9,84.8,49.8,34.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    ],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,71.4,55,54,27.9,40.6,33,22.2,80.5,80,41,0,0,0,0,0,0,0,0,0,0    ]
];

const extra = [500,450,480,700,300,355,200,150,380,450]//x measurements for later

calculateVarious();


function calculateVarious(){
    let suby = [];
    let subx = [];
    let subT = [];
    let another = [];
    let another2 = [];

    for (let k=0; k<dataframe.length; k++){
        for (let j=0; j<dataframe[0].length; j++){
            let subSum = 0;
            for (let i=0; i<dataframe.length; i++){
                subSum+= dataframe[i][j];
            }
            subx.push(subSum);
        }
    }
        
    for (let k=0; k<dataframe.length; k++){
        for (let i=0; i<dataframe[k].length; i++){
            suby.push(dataframe[k][i]);
            another2.push(extra[i]);
        }
    }
    
    for (let k=0; k<dataframe.length-1; k++){
        let row=[];
        let row2=[];
        for (let j=0; j<dataframe.length; j++){
            for (let i=0; i<dataframe[k].length; i++){
                if (j==k){
                    row.push(1)
                    row2.push(extra[i])
                } else {
                    row.push(0)
                    row2.push(0)
                }
            }
        }
        subT.push(row)
        another.push(row2)
    }


    let fullModel = [];
    let reducedModelyx = [];
    let reducedModelyt = [];
    let reducedModelyxt = [];
    let covariateModel = [];
    let covMod2 = [];
    let covMod3 = [];
    let fullModel2 = [];
    let modxt = [];
    let modxn = [];
    let modnTn = [];
    let modelYn = [];
    let dumbModel = [];
    let newYNT = [];
    let rmxnt = [];
    let modelyxn = [];
    let modelnt = [];
    let newFullModel = [];
    let backwards = [];


    //Test other one
    let byxt = [];
    let byt = [];
    let byx = [];
    byxt.push(newdata[0]);
    byxt.push(newdata[1]);
    byxt.push(newdata[2]);
    byxt.push(newdata[3]);
    byxt.push(newdata[4]);
    byt.push(newdata[0]);
    byt.push(newdata[2]);
    byt.push(newdata[3]);
    byt.push(newdata[4]);
    byx.push(newdata[0]);
    byx.push(newdata[1]);

    let modelBxyt = doRegression(byxt);
    let modelByt = doRegression(byt);
    let modelByx = doRegression(byx);


    //yt is the ssb
    backwards.push(suby);
    newFullModel.push(suby);
    modelnt.push(another2);
    modelyxn.push(suby);
    newYNT.push(suby);
    dumbModel.push(suby);
    fullModel.push(suby);
    modelYn.push(suby);
    covariateModel.push(suby);
    covMod2.push(suby);
    reducedModelyt.push(suby);
    reducedModelyxt.push(suby);
    reducedModelyx.push(suby);
    covMod3.push(suby);
    fullModel2.push(suby);
    modxt.push(subx);
    modxn.push(subx);
    rmxnt.push(subx);
    modnTn.push(another2);
    modelyxn.push(subx);
    for (let i=0; i<subT.length; i++){
        fullModel.push(subT[i]);
        fullModel2.push(subT[i]);
        reducedModelyxt.push(subT[i]);
        reducedModelyt.push(subT[i]);
        modxt.push(subT[i]);
        newYNT.push(subT[i]);
        rmxnt.push(subT[i]);
        modelnt.push(subT[i]);
        newFullModel.push(subT[i]);
    }
    newFullModel.push(another2);
    fullModel.push(subx);
    fullModel2.push(subx);
    reducedModelyxt.push(subx);
    reducedModelyx.push(subx);
    covMod3.push(subx);
    for (let i=0; i<another.length; i++){
        fullModel2.push(another[i]);
        covariateModel.push(another[i]);
        covMod2.push(another[i]);
        modnTn.push(another[i]);
        newFullModel.push(another[i]);
        backwards.push(another[i])
    }
    covariateModel.push(subx);
    covMod3.push(another2);
    fullModel.push(another2);
    modxn.push(another2);
    modelYn.push(another2);
    newYNT.push(another2);
    rmxnt.push(another2);
    modelyxn.push(another2);
    backwards.push(another2);

    let dumbRow = [];
    for (let i=0; i<another2.length; i++){
        dumbRow.push(another2[i]*subx[i])
    }
    dumbModel.push(dumbRow);
    
    let fm = doRegression(fullModel);
    let fmtt = doRegression(fullModel2);
    let trueFM = doRegression(newFullModel);
    let rmyxt = doRegression(reducedModelyxt);
    let rmyx = doRegression(reducedModelyx);
    let rmyt = doRegression(reducedModelyt);
    let rmcov = doRegression(covariateModel);
    let rmcov2 = doRegression(covMod2);
    let rmcov3 = doRegression(covMod3);
    let mxn = doRegression(modxn);
    let mxt = doRegression(modxt);
    let mnTn = doRegression(modnTn);
    let myn = doRegression(modelYn)
    let dumb = doRegression(dumbModel);
    let mynt = doRegression(newYNT);
    let modelrmxnt = doRegression(rmxnt);
    let rmyxn = doRegression(modelyxn);
    let rmnt = doRegression(modelnt)
    let backModel = doRegression(backwards)

    //This is the correct straight covariate measurement
    let covErrorSS = fm.RegressionSS - rmyt.RegressionSS - myn.RegressionSS;
    let CovBetween = myn.RegressionSS;
    let CovF = myn.RegressionSS / (covErrorSS / (dataframe[0].length -2));
    
    //These two below are actually correct; the overlap = time * covariate, and the_thing = time  inside of the big model
    //You actually need: fm, myn, trueFM, mynt, and backmodel
    //Go figure out why
    let overlap = trueFM.RegressionSS-mynt.RegressionSS;
    let the_thing = trueFM.RegressionSS-backModel.RegressionSS;
    let errorSS = fm.totalSS - fm.RegressionSS - overlap;
    let df_time = trueFM.df-mynt.df;
    let df_inter = trueFM.df-backModel.df;
    let errordf = dataframe[0].length*2 - df_time - df_inter;
    let MS_t = the_thing / df_time;
    let MS_tn = overlap / df_inter;
    let MS_error = errorSS / errordf;
    let F_time = MS_t / MS_error;
    let F_tn = MS_tn / MS_error;

    document.getElementById('results').innerHTML += "<br><br><br><br>ANCOVA:<br><br>";
    document.getElementById('results').innerHTML += "<br>Full ANOVA: df = "+(fm.df+rmyx.df)+", MS= "+MSS+", ME= "+MSE+", F= "+GroupsMS/MSE;
    document.getElementById('results').innerHTML += "<br>Subjects: df = "+(fm.df+rmyx.df)+", SS= "+(rmyx.RegressionSS)+", MS= "+SubjectMS+", F= "+SubjectMS/errorMS;
    document.getElementById('results').innerHTML += "<br>Groups: df = "+rmyt.df+", SS= "+rmyt.RegressionSS+", MS= "+GroupsMS+", F= "+GroupsMS/errorMS;
    document.getElementById('results').innerHTML += "<br>Covariate: df = "+myn.df+", SS= "+CovBetween+", MS= "+CovBetween+", F= "+CovF;
    document.getElementById('results').innerHTML += "<br>Error: df = "+(fm.totalN-rmyt.df-fm.df-rmyx.df)+", SS= "+(fm.totalSS-fm.RegressionSS)+", MS= "+errorMS;
}

function doRegression(data){
        //
    let N0 = data[0].length;
    let averages = [];
    let eachX1 = [];
    let eachXy = [];
    let eachXx = [];
    let sumSqs = [];
    let sums = [];
    
    for (let i=0; i<data.length; i++){
        averages.push(average(data[i]));
        sums.push(sum(data[i]))
        sumSqs.push(sumSquare(data[i]))
    }
    for (let i=1; i<data.length; i++){
        eachX1.push(sumSquare(data[i]) - ((sum(data[i])**2)/N0) )
    }
    for (let i=1; i<data.length; i++){
        eachXy.push(TwoDataSum(data[0], data[i]) - ((sum(data[0])*sum(data[i])) / N0))
    }
    for (let i=1; i<data.length; i++){
        for (let j=(i+1); j<data.length; j++){
            eachXx.push(TwoDataSum(data[i], data[j]) - ((sum(data[i])*sum(data[j])) / N0))
        }
    }
    let MatrixFuel = [];
    for (let i=0; i<data.length; i++){
        if (i==0){

        } else {
            for (let j=0; j<data.length; j++){
                if (i==0){
                    MatrixFuel.push(sum(data[i]))
                } else {
    
                }
            }
        }
        
    }
    let determinants = [];

    let bigA = [];
    for (let i=0; i<data.length; i++){
        let thisrow = [];
        if (i==0){
            for (let j=0; j<data.length; j++){
                if (j==0){
                    thisrow.push(N0)
                } else {
                    thisrow.push(sums[j])
                }
            }
        } else {
            for (let j=0; j<data.length; j++){
                if (j==0){
                    thisrow.push(sums[i])
                } else if (j==i) {
                    thisrow.push(sumSqs[i])
                } else {
                    thisrow.push(TwoDataSum(data[i],data[j]))
                }
            }
        }
        bigA.push(thisrow)
    }
    let denom = solveMatrix(bigA);
    
    for (let i=0; i<data.length; i++){
        let thisMat = [];
        if (i==0){
            for (let k=0; k<data.length; k++){
                let thisRow = [];
                for (let j=0; j<data.length; j++){
                    if (k==0){
                        thisRow.push(sums[j])
                    } else {
                        thisRow.push(TwoDataSum(data[j], data[k]))
                    }
                }
                thisMat.push(thisRow)
            }
            determinants.push(solveMatrix(thisMat))
        } else {
            for (let k=0; k<data.length; k++){
                let thisRow = [];
                if (k==0){
                    for (let j=0; j<data.length; j++){
                        if (j==0){
                            thisRow.push(N0)
                        } else {
                            if (j==i){
                                thisRow.push(sums[0])
                            } else {
                                thisRow.push(sums[j])
                            }
                        }
                    }
                } else {
                    for (let j=0; j<data.length; j++){
                        if (j==0){
                            thisRow.push(sums[k])
                        } else {
                            //This should only fire when k = i
                            if (j==i){
                                thisRow.push(TwoDataSum(data[k], data[0]))    
                            } else {
                                thisRow.push(TwoDataSum(data[j], data[k]))
                            }
                        }
                    }
                }
                thisMat.push(thisRow)
            }
            determinants.push(solveMatrix(thisMat))
        }
        

    }
    let Bs = [];
    for (let i=0; i<determinants.length; i++){
        Bs.push(determinants[i]/denom)
    }
    let ybar = [];
    let residuals = [];
    let yvars = [];
    let ytotals = [];

    for (let i=0; i<N0; i++) {
        let temp = 0;
        for (let j=0; j<Bs.length; j++){
            if (j==0){
                temp += Bs[0]
            } else {
                temp += Bs[j] * data[j][i]
            }
        }
        ybar.push(temp);
    }
    for (let i=0; i<N0; i++) {
        let temp = data[0][i] - ybar[i];
        residuals.push(temp);
    }
    for (let i=0; i<N0; i++) {
        let temp = ybar[i] - averages[0];
        yvars.push(temp);
    }
    for (let i=0; i<N0; i++) {
        let temp = data[0][i] - averages[0];
        ytotals.push(temp);
    }
    let SSM = sumSquare(yvars);
    let SSE = sumSquare(residuals);
    let SST = sumSquare(ytotals);
    let MSM = SSM / (data.length-1);
    let MSE = SSE / (N0-data.length);
    let F = MSM / MSE;
    let R2 =  SSM / SST;
    //let p = getPfromF(data.length, F, (data.length-1), (N0-data.length));

    return {"F":F,"RegressionSS":SSM,"RegressionMS":MSM,"ResidualSS":SSE,"ResidualsMS":MSE,"df":data.length-1,"residuals":N0-data.length,"totalSS":SST, "totalN": N0-1, "B": Bs[0], "R2":R2}
}

function SumSq(data) {
    let M = average(data);
    let temp = [];
    for (let i = 0; i < data.length; i++) {
        let temp1 = (data[i] - M) **2;
        temp.push(temp1);
    }
    return sum(temp);
}

</script>